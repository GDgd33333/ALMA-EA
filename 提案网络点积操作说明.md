# ALMA-EA 提案网络点积操作详细说明

## 目录
1. [点积操作概述](#点积操作概述)
2. [谁和谁做点积](#谁和谁做点积)
3. [智能体的观测信息](#智能体的观测信息)
4. [完整数据流](#完整数据流)
5. [代码实现细节](#代码实现细节)

---

## 点积操作概述

ALMA-EA的提案网络（Proposal Network）使用**点积注意力（Dot-Product Attention）**机制来计算智能体与任务之间的匹配分数，用于生成任务分配提案。

**关键文件**: `src/modules/agents/allocation_policies.py`

---

## 谁和谁做点积

### 点积操作的两个参与方

#### 1. **智能体嵌入 (Agent Embeddings)**

**来源**: 智能体的编码表示
- **形状**: `(batch_size, n_agents, attn_embed_dim)`
- **生成过程**:
  ```python
  # 第209行：获取智能体实体
  agent_x1 = x1[:, :nag]  # nag = n_agents
  
  # 第210-220行：可选地通过注意力机制增强
  if self.pi_ag_attn:
      agent_embeds = agent_x1 + self.attn(F.relu(agent_x1), ...)
  else:
      agent_embeds = agent_x1
  ```

#### 2. **任务嵌入 (Task Embeddings)**

**来源**: 任务的编码表示
- **形状**: `(batch_size, n_tasks, attn_embed_dim)`
- **生成过程**:
  ```python
  # 第188-206行：通过注意力机制聚合非智能体实体
  nonagent_x1 = x1[:, nag:]  # 非智能体实体
  nonagent_x2 = self.attn(F.relu(nonagent_x1), ...)
  
  # 第198-206行：按任务分组聚合
  if self.pi_pointer_net:
      # 将属于同一任务的非智能体实体嵌入求和
      task_x2 = th.bmm(nonagent_entity2task.transpose(1, 2), nonagent_x2)
  else:
      task_x2 = nonagent_x2.mean(dim=1)
  ```

### 点积计算

#### 模式1: 自回归模式 (`pi_autoreg=True`)

**代码位置**: `allocation_policies.py` 第76行

```python
# 第70-76行
curr_agent_embed = agent_embeds[:, [ai]]  # 当前智能体嵌入 (bs, 1, hd)

if self.pi_pointer_net:
    # 添加计数嵌入
    count_embeds = self.count_embed(th.stack([task_nonag_counts, task_ag_counts], dim=-1))
    # 点积计算
    logits = th.bmm(
        curr_agent_embed,                    # (bs, 1, hd)
        (task_embeds + count_embeds).transpose(1, 2)  # (bs, hd, n_tasks)
    ).squeeze(1) / self.scale_factor       # (bs, n_tasks)
```

**数学表示**:
```
logits[i, j] = (agent_embed[i] · task_embed[j]) / sqrt(attn_embed_dim)
```

#### 模式2: 标准模式 (`pi_autoreg=False`)

**代码位置**: `allocation_policies.py` 第136行

```python
# 第135-136行
if self.pi_pointer_net:
    logits = th.bmm(
        agent_embeds,              # (bs, n_agents, hd)
        task_embeds.transpose(1, 2)  # (bs, hd, n_tasks)
    ) / self.scale_factor          # (bs, n_agents, n_tasks)
```

**数学表示**:
```
logits[i, j, k] = (agent_embed[i, j] · task_embed[i, k]) / sqrt(attn_embed_dim)
```

### 点积结果的含义

- **logits[i, j]**: 智能体i对任务j的匹配分数
- **分数越高**: 表示该智能体更适合该任务
- **经过softmax**: 转换为任务分配概率分布

---

## 智能体的观测信息

### 智能体能看到什么？

**关键点**: 智能体看到的是**部分可观察的信息**，不是完全全局的！

#### 1. **实体信息 (Entities)**

**来源**: 环境提供的所有实体信息
- **包含内容**:
  - **智能体实体**: 所有智能体的状态（位置、血量、能量等）
  - **非智能体实体**: 任务相关的实体（如建筑、敌人等）

**代码位置**: `src/envs/firefighters/firefighters.py` 第476-520行

```python
def get_entities(self):
    all_entities = []
    for obj in self.objects:
        curr_ent = np.zeros(nf_entity, dtype=np.float32)
        # 实体类型 (one-hot)
        curr_ent[ind + obj.ent_id] = 1
        # 位置信息 (one-hot + 标量)
        curr_ent[ind + obj.x] = 1  # one-hot x
        curr_ent[ind + obj.y] = 1  # one-hot y
        curr_ent[ind] = obj.x / MAP_SIZE  # 标量 x
        curr_ent[ind + 1] = obj.y / MAP_SIZE  # 标量 y
        # 可用动作 (仅智能体)
        if obj.ent_type == 'agent':
            curr_ent[ind + iac] = avail_actions[obj.obj_id][iac]
        # 建筑属性 (仅建筑)
        if obj.ent_type == 'building':
            curr_ent[ind] = obj.health
            curr_ent[ind + 1] = int(obj.complete)
            curr_ent[ind + 2] = int(obj.burned_down)
            curr_ent[ind + 3] = obj.fire_strength
        all_entities.append(curr_ent)
    return all_entities
```

#### 2. **观测掩码 (Observation Mask)**

**作用**: 控制哪些实体对哪些智能体可见

**代码位置**: `src/envs/firefighters/firefighters.py` 第581-617行

```python
def get_masks(self):
    # 初始化：所有实体对所有智能体不可见
    obs_mask = np.ones((n_agents + n_buildings, n_agents + n_buildings), dtype=np.uint8)
    
    for agent in self.agents:
        if agent.sight_range is not None:
            # 获取可见对象
            vis_objs = self._vis_objs(agent.x, agent.y, agent.sight_range)
            for obj in vis_objs:
                # 标记为可见 (0 = 可见, 1 = 不可见)
                obs_mask[agent.obj_id, obj.obj_id] = 0
```

**obs_mask的含义**:
- `obs_mask[i, j] = 0`: 智能体i可以看到实体j
- `obs_mask[i, j] = 1`: 智能体i**看不到**实体j（超出视线范围）

#### 3. **注意力机制处理部分可观察性**

**代码位置**: `src/modules/agents/bases.py` 第20-35行

```python
def forward(self, inputs):
    entities = inputs['entities']      # (bs, ts, n_entities, entity_dim)
    obs_mask = inputs['obs_mask']      # (bs, ts, n_entities, n_entities)
    entity_mask = inputs['entity_mask'] # (bs, ts, n_entities)
    
    # 1. 编码所有实体
    x1 = self.fc1(entities)  # (bs*ts, n_entities, attn_embed_dim)
    
    # 2. 注意力机制：智能体只能关注可见的实体
    attn_outs = self.attn(
        F.relu(x1), 
        pre_mask=obs_mask,      # 掩码：不可见实体的注意力权重设为-inf
        post_mask=agent_mask   # 掩码：非活跃智能体的输出设为0
    )
    # 结果：每个智能体得到聚合了可见实体信息的嵌入
```

**关键机制**:
- 注意力层使用`obs_mask`来限制智能体只能关注可见实体
- 不可见实体的注意力权重被设为`-inf`，经过softmax后变为0
- 因此，智能体的嵌入只包含**可见实体的信息**

### 总结：智能体的观测范围

| 信息类型 | 可见性 | 说明 |
|---------|--------|------|
| **自己的状态** | ✅ 完全可见 | 智能体总是能看到自己的完整状态 |
| **其他智能体** | ⚠️ 部分可见 | 取决于视线范围（sight_range） |
| **任务实体（建筑等）** | ⚠️ 部分可见 | 取决于视线范围和距离 |
| **全局状态** | ❌ 不可见 | 智能体**不能**直接访问全局状态 |

**重要**: 虽然`entities`包含所有实体的信息，但通过`obs_mask`和注意力机制，每个智能体只能"看到"和"使用"可见实体的信息。

---

## 完整数据流

### 从环境到提案网络的完整流程

```
1. 环境生成实体信息
   └─> get_entities(): 所有实体的状态
   └─> get_masks(): obs_mask (可见性掩码)

2. 实体编码
   └─> EntityBase.forward():
       ├─> fc1(entities) -> x1
       ├─> 注意力机制 (使用obs_mask过滤不可见实体)
       └─> fc2 -> agent_embeds

3. 任务嵌入生成
   └─> AllocationPolicy.forward():
       ├─> 非智能体实体通过注意力聚合
       ├─> 按任务分组求和
       └─> task_embeds

4. 点积计算
   └─> th.bmm(agent_embeds, task_embeds.transpose(1, 2))
       └─> logits: (bs, n_agents, n_tasks)

5. 生成提案
   └─> softmax(logits) -> 任务分配概率
   └─> 采样 -> 任务分配提案
```

### 具体示例

假设有3个智能体和2个任务：

```python
# 1. 环境提供
entities = [
    [agent0_features],  # 智能体0
    [agent1_features],  # 智能体1
    [agent2_features],  # 智能体2
    [building0_features],  # 任务0的建筑
    [building1_features],  # 任务1的建筑
]

obs_mask = [
    [0, 0, 1, 0, 1],  # agent0: 能看到agent0, agent1, building0，看不到agent2, building1
    [0, 0, 0, 1, 0],  # agent1: 能看到所有智能体，能看到building1
    [1, 0, 0, 0, 0],  # agent2: 只能看到自己
]

# 2. 编码后
agent_embeds = [
    [agent0_embed],  # 聚合了agent0, agent1, building0的信息
    [agent1_embed],  # 聚合了所有智能体和building1的信息
    [agent2_embed],  # 只包含自己的信息
]

task_embeds = [
    [task0_embed],  # 来自building0的聚合
    [task1_embed],  # 来自building1的聚合
]

# 3. 点积计算
logits = [
    [score(agent0, task0), score(agent0, task1)],  # agent0对两个任务的匹配分数
    [score(agent1, task0), score(agent1, task1)],  # agent1对两个任务的匹配分数
    [score(agent2, task0), score(agent2, task1)],  # agent2对两个任务的匹配分数
]
```

---

## 代码实现细节

### 关键代码片段

#### 1. 点积计算（自回归模式）

```python
# allocation_policies.py 第70-76行
for ai in range(self.args.n_agents):
    curr_agent_embed = agent_embeds[:, [ai]]  # (bs, 1, hd)
    
    if self.pi_pointer_net:
        # 添加计数信息（已分配智能体数量、非智能体实体数量）
        count_embeds = self.count_embed(
            th.stack([task_nonag_counts, task_ag_counts], dim=-1)
        )
        # 点积：智能体嵌入 × 任务嵌入
        logits = th.bmm(
            curr_agent_embed,                           # (bs, 1, hd)
            (task_embeds + count_embeds).transpose(1, 2)  # (bs, hd, n_tasks)
        ).squeeze(1) / self.scale_factor              # (bs, n_tasks)
```

#### 2. 点积计算（标准模式）

```python
# allocation_policies.py 第135-136行
if self.pi_pointer_net:
    logits = th.bmm(
        agent_embeds,              # (bs, n_agents, hd)
        task_embeds.transpose(1, 2)  # (bs, hd, n_tasks)
    ) / self.scale_factor          # (bs, n_agents, n_tasks)
```

#### 3. 观测掩码的使用

```python
# bases.py 第32-33行
attn_outs = self.attn(
    F.relu(x1), 
    pre_mask=obs_mask,      # 不可见实体的注意力权重 = -inf
    post_mask=agent_mask    # 非活跃智能体的输出 = 0
)
```

#### 4. 注意力层中的掩码应用

```python
# attention.py 第109-113行
attn_logits = th.bmm(query_spl, key_spl) / self.scale_factor

if pre_mask is not None:
    pre_mask_rep = pre_mask.repeat_interleave(self.n_heads, dim=0)
    # 不可见实体的注意力分数设为-inf
    attn_logits = attn_logits.masked_fill(
        pre_mask_rep[:, :, :ne].bool(), -float('Inf')
    )
```

---

## 总结

### 点积操作

- **操作**: `智能体嵌入 · 任务嵌入`
- **目的**: 计算智能体与任务的匹配分数
- **结果**: 生成任务分配提案

### 智能体的观测

- **实体信息**: 包含所有实体的状态（智能体+非智能体）
- **可见性控制**: 通过`obs_mask`限制可见范围
- **信息聚合**: 注意力机制只聚合可见实体的信息
- **结论**: 智能体看到的是**部分可观察的信息**，不是完全全局的

### 关键设计

1. **部分可观察性**: 通过`obs_mask`实现，符合实际多智能体场景
2. **注意力机制**: 自动过滤不可见实体，只使用可见信息
3. **点积注意力**: 高效计算智能体-任务匹配分数
4. **任务嵌入**: 通过聚合任务相关实体生成，包含任务上下文信息

这种设计使得ALMA-EA能够在部分可观察的多智能体环境中有效地进行任务分配。

